A kódban használt rnd és randModel változók különböző célokat szolgálnak a VIBE (Visual Background Extractor) algoritmusban.

rnd: Ez a változó egy Random típusú példány, amelyet a Random osztályból hozunk létre. Ennek a változónak a segítségével generálunk véletlenszerű számokat a kódban, például az int rand = rnd.Next(0, FI - 1); sorban. Ez a kódrészlet egy véletlenszerű számot generál a nullától (0) az FI - 1-ig tartó tartományban.

randModel: Ez a változó az algoritmusban az egyik mintamodellel kapcsolatos. Amikor a program megvizsgálja a pixel körüli mintákat és összehasonlítja azokat a modellekkel a háttér felismeréséhez, a randModel segít abban, hogy véletlenszerűen kiválassza, melyik minta legyen az, amelyet frissíteni kell az aktuális pixelhez kapcsolódó modellben.

Ez a két változó tehát különböző célokat szolgál a kódban. Az rnd a véletlenszerű számok generálására szolgál, míg a randModel a mintamodellek kezelésére és frissítésére vonatkozik az algoritmusban.

/*
    int compareCount = 0;
    byte[,,] tomb = new byte[width, height, 2];
    if(i % 2 == 0)
    {
        tomb[x, y, 0] = frame.Data[y, x, 0]; 
    }
    else 
    {
        tomb[x, y, 1] = frame.Data[y, x, 0];
        if(compareCount/(width*height) >= 0.75)
        {
            ReinitializeModel(frameImage);
        }
    }
    if(tomb[x, y, 0] == tomb[x, y, 1] && i >= 1) 
    {
        compareCount++;
    }
*/

az alabbi kodban egy vibe algoritmus van bemutatva, a Form1_Load fuggveny leirasa: az aktualis framek szamat beallitjuk 1-re, letrehozunk egy valtozot a video eleresere, ezt kovetoen megnezzuk hogy letezik-e ilyen video, beolvassuk a videot es az aktualis framet, beolvassuk a frameket, majd letrehozunk ket imageboxot, az elsobe az aktualis videot, a masikba a szegmentalt kepet jelenitsuk meg. Ha nem letezik ilyen video fajl nem talalhato kivetelt dob. Beallitjuk a trackbar aktualis erteket, minimum es maximum erteket.                                                                                                                                                                                  A getRandomNeighborXCoordinate fuggvenynek egy parametere van az x koordinata, letrehozok egy valtozot az eltolasra, illetve egy random valtozot, ha tul megyek a kepen, beallitom az x koordinatat a kep vegere, ha az elejen vagyok, beallitom az x erteket 1-re, kulonben kigeneralok veletlen szamot -1,1 kozott, es visszadom x + eltolast.                                                                                                        A getRandomNeighborYCoordinate fuggvenynek egy parametere van az y koordinata, letrehozok egy valtozot az eltolasra, illetve egy random valtozot, ha tul megyek a kepen, beallitom az y koordinatat a kep vegere, ha az elejen vagyok, beallitom az y erteket 1-re, kulonben kigeneralok veletlen szamot -1,1 kozott, es visszadom y + eltolast.  
                                                                                                   A modell ujrainicializalasara letrehozok egy fuggvenyt ReinitializeModel, parameterkent megadok egy szines kepet, a fuggveny belsejeben beallitok egy szegmentalt kepet, majd vegigmegyek a kep x,y koordinatajan, vegigmegyek a pixelek szamaig egy ciklussal es beallitom a mintat a szines kep ertekere.                                                                                                                                                                                        Most a legfontosabb resz kovetkezik a vibe algoritmus, amely aszinkron modon mukodik, itt a szelesseget es magassagat a frame ertekehez allitom, letrehozok egy veletlen szamot, majd elkezdodik egy thread, ami arra valo, hogy a video kozben egyszerre megtortenik a frame kinyeres is, es nem fagy be a program, vegigmegyek az osszes framen, elkapjuk a frameket es lementjuk egy fajlba, felszabaditjuk, hogy innentol kezdve ne hasznaljunk tobb memoriat, itt tortenik meg a frame kiiras, ugye mindig beolvassuk a soron kovetkezo framet, ha az elso framenel vagyunk ujrainicializaljuk a modellt, a fent emlitett ReinitializeModel segitsegevel, vegigmegyunk a kepek x,y koordinatajan, letrehozok egy szamlalot, vegigmegyek a pixelek szamaig, kiszamitom a pixelek kozti tavolsagot, es megnezzuk hogy a tavolsag erteke kisebb-e, mint a pixelek radius, ekkor noveljuk a szamlalo erteket 1-el. Ha a szamlalo erteke nagyobb mint 2, kilepunk a ciklusbol, tehat ebben az esetben beallitjuk a szegmentalt kepet hattermodellnek, majd egy veletlen szamot hozunk letre 0 es a frissitesek szamaig, ha a veletlen szam 0, akkor a modellnek is letrehozunk egy veletlen szamot, 0 es a pixelek szamaig, es beallitjuk ezt a veletlen szamot a modellbe, majd ujra generalunk veletlen szamot, 0 es a frissitesek szamaig, ha a veletlen szam erteke 0, ket valtozoba elmentjuk a szomszedos pixelek x, y erteket fuggvenyhivassal, itt azonban ellenorizni kell, hogy a valtozo erteke nem lep-e tul a pixeleken x,y iranyba,  kkor a modellnek is letrehozunk egy veletlen szamot, 0 es a pixelek szamaig, es beallitjuk ezt a veletlen szamot a modellbe, egyebkent tehat ha nem hatterpixelrol volt szo, akkor beallitjuk a modellt eloter pixelnek, majd a ket imageboxban meegjelenitjuk az RGB es Gray kepet. 